/**
 * Output formatters for different file formats
 */

const fs = require('fs');
const path = require('path');

// Format as CSS custom properties
function formatAsCSS(designSystem) {
  let css = '/* Generated by MindCore · Atlas */\n';
  css += `/* Theme: ${designSystem.theme} | Seed: ${designSystem.seed} */\n\n`;
  css += ':root {\n';
  
  // Colors
  css += '  /* Colors */\n';
  Object.entries(designSystem.colors).forEach(([colorName, scale]) => {
    Object.entries(scale).forEach(([shade, value]) => {
      css += `  --color-${colorName}-${shade}: ${value};\n`;
    });
  });
  
  // Typography
  css += '\n  /* Typography */\n';
  Object.entries(designSystem.typography.fontSize).forEach(([name, value]) => {
    css += `  --font-size-${name}: ${value}px;\n`;
  });
  
  css += '\n  /* Font Families */\n';
  css += `  --font-primary: ${designSystem.typography.fonts.primary};\n`;
  css += `  --font-heading: ${designSystem.typography.fonts.heading};\n`;
  css += `  --font-mono: ${designSystem.typography.fonts.mono};\n`;
  
  css += '\n  /* Font Weights */\n';
  Object.entries(designSystem.typography.fontWeight).forEach(([name, value]) => {
    css += `  --font-weight-${name}: ${value};\n`;
  });
  
  css += '\n  /* Line Heights */\n';
  Object.entries(designSystem.typography.lineHeight).forEach(([name, value]) => {
    css += `  --line-height-${name}: ${value};\n`;
  });
  
  // Spacing
  css += '\n  /* Spacing */\n';
  Object.entries(designSystem.spacing.spacing).forEach(([name, value]) => {
    css += `  --spacing-${name}: ${value};\n`;
  });
  
  // Border Radius
  css += '\n  /* Border Radius */\n';
  Object.entries(designSystem.spacing.borderRadius).forEach(([name, value]) => {
    css += `  --radius-${name}: ${value};\n`;
  });
  
  // Shadows
  css += '\n  /* Shadows */\n';
  Object.entries(designSystem.spacing.shadows).forEach(([name, value]) => {
    css += `  --shadow-${name}: ${value};\n`;
  });
  
  css += '}\n';
  
  return css;
}

// Format as JSON
function formatAsJSON(designSystem) {
  return JSON.stringify(designSystem, null, 2);
}

// Format as JavaScript module
function formatAsJS(designSystem) {
  let js = '/* Generated by MindCore · Atlas */\n';
  js += `/* Theme: ${designSystem.theme} | Seed: ${designSystem.seed} */\n\n`;
  js += 'module.exports = ';
  js += JSON.stringify(designSystem, null, 2);
  js += ';\n';
  
  return js;
}

// Format as TypeScript module
function formatAsTS(designSystem) {
  let ts = '/* Generated by MindCore · Atlas */\n';
  ts += `/* Theme: ${designSystem.theme} | Seed: ${designSystem.seed} */\n\n`;
  ts += 'export const designSystem = ';
  ts += JSON.stringify(designSystem, null, 2);
  ts += ' as const;\n\n';
  ts += 'export default designSystem;\n';
  
  return ts;
}

// Format as Tailwind CSS config
function formatAsTailwind(designSystem) {
  let config = '/* Generated by MindCore · Atlas */\n';
  config += `/* Theme: ${designSystem.theme} | Seed: ${designSystem.seed} */\n\n`;
  config += '/** @type {import(\'tailwindcss\').Config} */\n';
  config += 'module.exports = {\n';
  config += '  theme: {\n';
  config += '    extend: {\n';
  
  // Colors
  config += '      colors: {\n';
  Object.entries(designSystem.colors).forEach(([colorName, scale]) => {
    config += `        '${colorName}': {\n`;
    Object.entries(scale).forEach(([shade, value]) => {
      config += `          '${shade}': '${value}',\n`;
    });
    config += '        },\n';
  });
  config += '      },\n';
  
  // Font families
  config += '      fontFamily: {\n';
  config += `        'primary': ${JSON.stringify(designSystem.typography.fonts.primary.split(',').map(f => f.trim()))},\n`;
  config += `        'heading': ${JSON.stringify(designSystem.typography.fonts.heading.split(',').map(f => f.trim()))},\n`;
  config += `        'mono': ${JSON.stringify(designSystem.typography.fonts.mono.split(',').map(f => f.trim()))},\n`;
  config += '      },\n';
  
  // Font sizes - convert px to rem (assuming 16px base)
  config += '      fontSize: {\n';
  Object.entries(designSystem.typography.fontSize).forEach(([name, value]) => {
    const remValue = (value / 16).toFixed(3);
    config += `        '${name}': '${remValue}rem',\n`;
  });
  config += '      },\n';
  
  // Font weights
  config += '      fontWeight: {\n';
  Object.entries(designSystem.typography.fontWeight).forEach(([name, value]) => {
    config += `        '${name}': '${value}',\n`;
  });
  config += '      },\n';
  
  // Line heights
  config += '      lineHeight: {\n';
  Object.entries(designSystem.typography.lineHeight).forEach(([name, value]) => {
    config += `        '${name}': '${value}',\n`;
  });
  config += '      },\n';
  
  // Spacing
  config += '      spacing: {\n';
  Object.entries(designSystem.spacing.spacing).forEach(([name, value]) => {
    config += `        '${name}': '${value}',\n`;
  });
  config += '      },\n';
  
  // Border radius
  config += '      borderRadius: {\n';
  Object.entries(designSystem.spacing.borderRadius).forEach(([name, value]) => {
    config += `        '${name}': '${value}',\n`;
  });
  config += '      },\n';
  
  // Box shadows
  config += '      boxShadow: {\n';
  Object.entries(designSystem.spacing.shadows).forEach(([name, value]) => {
    config += `        '${name}': '${value}',\n`;
  });
  config += '      },\n';
  
  config += '    },\n';
  config += '  },\n';
  config += '  plugins: [],\n';
  config += '};\n';
  
  return config;
}

// Format component tokens as separate CSS
function formatComponentsAsCSS(components) {
  let css = '/* Component Tokens */\n\n';
  
  Object.entries(components).forEach(([componentName, variants]) => {
    css += `/* ${componentName.charAt(0).toUpperCase() + componentName.slice(1)} */\n`;
    
    Object.entries(variants).forEach(([variantName, tokens]) => {
      css += `.${componentName}-${variantName} {\n`;
      Object.entries(tokens).forEach(([prop, value]) => {
        const cssProp = prop.replace(/([A-Z])/g, '-$1').toLowerCase();
        css += `  ${cssProp}: ${value};\n`;
      });
      css += '}\n\n';
    });
  });
  
  return css;
}

// Write all output files
function writeOutputFiles(designSystem, outputDir, formats, includeComponents) {
  const files = [];
  
  // Create output directory
  if (!fs.existsSync(outputDir)) {
    fs.mkdirSync(outputDir, { recursive: true });
  }
  
  // Write base files
  if (formats.includes('css')) {
    const cssPath = path.join(outputDir, 'tokens.css');
    fs.writeFileSync(cssPath, formatAsCSS(designSystem));
    files.push(cssPath);
    
    if (includeComponents && designSystem.components) {
      const componentsCssPath = path.join(outputDir, 'components.css');
      fs.writeFileSync(componentsCssPath, formatComponentsAsCSS(designSystem.components));
      files.push(componentsCssPath);
    }
  }
  
  if (formats.includes('json')) {
    const jsonPath = path.join(outputDir, 'tokens.json');
    fs.writeFileSync(jsonPath, formatAsJSON(designSystem));
    files.push(jsonPath);
  }
  
  if (formats.includes('js')) {
    const jsPath = path.join(outputDir, 'tokens.js');
    fs.writeFileSync(jsPath, formatAsJS(designSystem));
    files.push(jsPath);
  }
  
  if (formats.includes('ts')) {
    const tsPath = path.join(outputDir, 'tokens.ts');
    fs.writeFileSync(tsPath, formatAsTS(designSystem));
    files.push(tsPath);
  }
  
  if (formats.includes('tailwind')) {
    const tailwindPath = path.join(outputDir, 'tailwind.config.js');
    fs.writeFileSync(tailwindPath, formatAsTailwind(designSystem));
    files.push(tailwindPath);
  }
  
  // Write README
  const readmePath = path.join(outputDir, 'README.md');
  const readme = generateReadme(designSystem);
  fs.writeFileSync(readmePath, readme);
  files.push(readmePath);
  
  return files;
}

// Generate README for the design system
function generateReadme(designSystem) {
  return `# Design System - ${designSystem.theme}

Generated by **MindCore · Atlas**

## Theme
**${designSystem.theme}**

## Seed
\`${designSystem.seed}\`

## Usage

### CSS
\`\`\`css
@import './tokens.css';

.my-component {
  color: var(--color-primary-500);
  font-size: var(--font-size-lg);
  padding: var(--spacing-4);
  border-radius: var(--radius-md);
  box-shadow: var(--shadow-md);
}
\`\`\`

### JavaScript/TypeScript
\`\`\`javascript
import tokens from './tokens.js';

const primaryColor = tokens.colors.primary['500'];
const spacing = tokens.spacing.spacing['4'];
\`\`\`

## Regeneration
To regenerate this exact design system, run:
\`\`\`bash
atlas generate --theme ${designSystem.theme} --seed ${designSystem.seed}
\`\`\`

## Color Palette
${Object.keys(designSystem.colors).map(color => `- **${color}**`).join('\n')}

## Typography
- Font Family: ${designSystem.typography.fonts.primary}
- Base Font Size: ${designSystem.typography.fontSize.base}px

## Components
${designSystem.components ? 'Component tokens included in components.css' : 'Component tokens not generated'}

---

*Generated on ${designSystem.meta.generated}*
`;
}
formatAsTailwind,
  
module.exports = {
  formatAsCSS,
  formatAsJSON,
  formatAsJS,
  formatAsTS,
  writeOutputFiles,
};
